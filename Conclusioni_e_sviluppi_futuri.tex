%TODO
% workflow con webhooks
% notifiche push (si potrebbe usare un denormalizer?)
% app mobile per riceverle
% https
% marcatura degli errori come "gestito" e conseguente archiviazione
% integrazione con sistemi di tracking (?)
% aggiungere più mole-contacts
% aggiungere un sistema di query
% mole-contacts -> caching degli errori in locale quando non c'è rete (buffering)

% migliorare la gestione dgli widget e plugin per l'aggiunta a caldo

% possibili nuovi denormalizzatori

% bench e vm sulla stessa macchina
% vm con cpu pin
% ramp up

-- ABSTRACT --

Mole.io è un sistema centralizzato per la raccolta e l'aggregazione di messaggi provenienti da applicazioni remote.

L'approccio comune alla creazione e gestione di questi messaggi, detti \textit{log}, presenta la criticità specifica della \textit{località}: abitualmente i file di log vengono salvati nella medesima macchina sulla quale sta operando l'applicazione che li ha prodotti.

All'aumentare del numero di applicazioni da gestire e del numero di macchine in produzione, diventa sempre più difficoltoso ottenere un \textit{feedback} veloce dello stato di ogni software e delle eventuali situazioni di errore in cui le applicazioni si trovano.

Da questo scenario l'ideazione di Mole.io, un sistema in grado di raccogliere, catalogare e aggregare messaggi da installazioni remote. Componenti di Mole.io residenti all'interno delle applicazioni da monitorare rendono le stesse in grado di inviare le notifiche al server centrale, invertendo, di fatto, il paradigma della generazione e conseguente consultazione dei log da \textit{pull} a \textit{push}. La centralizzazione di questo tipo di messaggi, ne facilità la reperibilità, mentre la loro aggregazione permette di ottenere una visione globale della situazione di ogni applicazione in produzione. Questo nuovo approccio permette agli sviluppatori di identificare, in breve tempo, il manifestarsi di un malfunzionamento in qualunque installazione e reagire rapidamente proponendo una azione risolutiva.

Mole.io è in grado di raccogliere diverse tipologie di messaggi, non strutturati a priori, rendendo così questo strumento adatto a differenti ambiti applicativi, come il \textit{Datamining} e la \textit{Business Intelligence}.

L'architettura del sistema permette l'aggiunta o la rimozione a \textit{runtime} di plugin detti \textit{denormalizzatori}. Questi garantiscono la possibilità di trattare efficacemente le diverse tipologie di messaggi ricevuti dal server principale.

Il sistema è stato interamente sviluppato utilizzando Node.js, una piattaforma che permette di realizzare applicazioni web \textit{server-side} in JavaScript. 
La scalabilità dell'applicazione è garantita dall'adozione di un database \textit{schema-less} come MongoDB e dall'utilizzo di un gestore di code, RabbitMQ, per lo scambio di informazioni tra le diverse componenti del sistema.

La piattaforma scelta per il \textit{deploy} dell'applicazione in produzione è \textit{Microsoft Azure}, un sistema \textit{PaaS} distribuito, con il quale è possibile creare architetture facilmente scalabili, per supportare la variabilità del carico di lavoro richiesto.
